/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;

import android.content.Context;
import android.content.Intent;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuInflater;
import com.actionbarsherlock.view.MenuItem;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.gui.MsfPreferences;
import it.evilsocket.dsploit.gui.dialogs.ChoiceDialog;
import it.evilsocket.dsploit.gui.dialogs.ErrorDialog;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.gui.dialogs.ListChoiceDialog;
import it.evilsocket.dsploit.net.Databases.Exploitdb;
import it.evilsocket.dsploit.net.Databases.Metasploit;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Vulnerability;
import it.evilsocket.dsploit.net.Target.Exploit;
import it.evilsocket.dsploit.net.metasploit.MsfExploit;

public class ExploitFinder extends Plugin
{
  private ToggleButton       mSearchToggleButton = null;
  private ProgressBar	       mSearchProgress = null;
  private ListView 		       mListView = null;
  private boolean	           mRunning = false;
  private Thread			       mThread = null;
  private ArrayList<Exploit> mResults = new ArrayList<Exploit>();
  private ExploitAdapter     mAdapter = null;

  public class ExploitAdapter extends ArrayAdapter<Exploit>
  {
    class ExploitHolder
    {
      ImageView  itemImage;
      TextView   itemTitle;
      TextView   itemDescription;
    }

    public ExploitAdapter(  ) {
      super( ExploitFinder.this, R.layout.plugin_exploit_finder_item  );
    }

    @Override
    public View getView( int position, View convertView, ViewGroup parent ) {
      View 		 row    = convertView;
      ExploitHolder holder = null;

      if( row == null )
      {
        LayoutInflater inflater = ( LayoutInflater )ExploitFinder.this.getSystemService( Context.LAYOUT_INFLATER_SERVICE );
        row = inflater.inflate( R.layout.plugin_exploit_finder_item , parent, false );

        holder = new ExploitHolder();

        holder.itemImage  	   = ( ImageView )row.findViewById( R.id.itemIcon );
        holder.itemTitle  	   = ( TextView )row.findViewById( R.id.itemTitle );
        holder.itemDescription = ( TextView )row.findViewById( R.id.itemDescription );

        row.setTag(holder);
      }
      else
      {
        holder = ( ExploitHolder )row.getTag();
      }

      Exploit exploit = getItem(position);

      if( exploit instanceof MsfExploit )
      {
        holder.itemTitle.setText
                           (
                             Html.fromHtml
                                    (
                                      "<b>" + exploit.getName()+ "</b>"
                                    )
                           );
      }
      else
        holder.itemTitle.setText( exploit.getName() );

      holder.itemTitle.setTypeface( null, Typeface.NORMAL );
      holder.itemImage.setImageResource( exploit.getDrawableResourceId() );
      holder.itemDescription.setText( exploit.getDescription() );

      return row;
    }
  }

  public ExploitFinder() {
    super
    (

      R.string.exploit_finder,
      R.string.exploit_finder_desc,

      new Target.Type[]{ Target.Type.ENDPOINT, Target.Type.REMOTE },
      R.layout.plugin_exploit_finder,
      R.drawable.action_exploit_finder
    );
  }

  private void setStartedState( ) {
    mSearchProgress.setVisibility( View.VISIBLE );
    mRunning = true;

    mThread = new Thread( new Runnable()
    {
      @Override
      public void run()
      {
        boolean msf_only = System.getSettings().getBoolean("SEARCH_MSF_ONLY", false);
        boolean found_something = false;

        for ( final Vulnerability vuln : System.getCurrentTarget().getVulnerabilities())
        {
          if( !mRunning ) return;
          Exploit ex = null;

          mResults.clear();

          if(vuln.osvdb_id!=0)
          {
            if( vuln.has_msf_exploit )
              ex = Metasploit.search_by_osvdb(vuln.osvdb_id);

            if( ex != null ) {
              mResults.add(ex);
            }
            else if(!msf_only) {
              ArrayList<Exploit> exploits = Exploitdb.search_by_osvdb(vuln.osvdb_id);
              if( exploits != null )
                mResults.addAll(exploits);
            }
          }
          if(vuln.cve_id!=null)
          {
            // substring remove "CVE-"
            ex = Metasploit.search_by_cve(vuln.cve_id.substring(4));
            if(ex != null)
              mResults.add(ex);
            else if(!msf_only)
              mResults.addAll(Exploitdb.search_by_cveid(vuln.cve_id.substring(4)));
          }
          if(!found_something && !mResults.isEmpty())
            found_something = true;
          for(final Exploit exp : mResults)
          {
            System.addExploit(vuln, exp);

            ExploitFinder.this.runOnUiThread( new Runnable() {
              @Override
              public void run()
              {
                mAdapter.add(exp);
              }
            });
          }
        }
        if( !found_something )
        {

          ExploitFinder.this.runOnUiThread( new Runnable() {
            @Override
            public void run()
            {
              new FinishDialog( getString(R.string.warning), getString(R.string.no_exploits_found), ExploitFinder.this ).show();
            }
          });
        }
        ExploitFinder.this.runOnUiThread( new Runnable() {
          @Override
          public void run()
          {
            setStoppedState();
          }
        });
      }
    });

    mThread.start();
  }

  private void setStoppedState( ) {
    try
    {
      if( mThread != null )
      {
        mThread.interrupt();
        mThread.stop();
      }
    }
    catch( Exception e )
    {

    }

    mRunning = false;
    mSearchToggleButton.setChecked( false );
    mSearchProgress.setVisibility( View.GONE );
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu){
    MenuInflater inflater = getSupportMenuInflater();
    inflater.inflate(R.menu.exploit_finder, menu);
    return super.onCreateOptionsMenu(menu);
  }

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    Target t = System.getCurrentTarget();

    if( !t.hasOpenPorts())
      new FinishDialog( getString(R.string.warning), getString(R.string.no_open_ports), this ).show();

    else if( !t.hasOpenPortsWithService())
      new FinishDialog( getString(R.string.warning), getString(R.string.no_infos_on_target), this ).show();

    else if( !t.hasVulnerabilities())
      new FinishDialog( getString(R.string.warning), getString(R.string.no_vulnerabilities_found), this ).show();

    mSearchToggleButton = ( ToggleButton )findViewById( R.id.searchToggleButton );
    mSearchProgress	   = ( ProgressBar )findViewById( R.id.searchActivity );
    mListView		   = ( ListView )findViewById( android.R.id.list );
    mAdapter		   = new ExploitAdapter();

    for(Exploit exp : System.getCurrentExploits()) {
      mAdapter.add(exp);
    }


    mListView.setAdapter( mAdapter );


    mListView.setOnItemClickListener( new OnItemClickListener(){
      public void onItemClick( AdapterView<?> parent, View v, final int position, long id ) {
        Exploit exp = mAdapter.getItem(position);

        if(exp==null)
          return;

        if(exp instanceof MsfExploit) {
          final MsfExploit msfEx = (MsfExploit)exp;
          final ArrayList<Integer> availableChoices = new ArrayList<Integer>();
          final String[] stringChoices;
          if(true) // TODO: recognize if an exploit is running
            availableChoices.add(R.string.exploit_launch);
          if(msfEx.getOptions().length > 0)
            availableChoices.add(R.string.exploit_edit_options);
          if(msfEx.getCurrentPayload()!=null)
            availableChoices.add(R.string.payload_edit_settings);
          if(msfEx.getPayloads().length > 1)
            availableChoices.add(R.string.exploit_choose_payload);
          if(msfEx.getTargets().length > 1)
            availableChoices.add(R.string.exploit_choose_target);
          if(msfEx.getUrl()!=null && !msfEx.getUrl().isEmpty())
            availableChoices.add(R.string.open_url);
          if(msfEx.getFullDescription()!=null)
            availableChoices.add(R.string.show_full_description);
          new ListChoiceDialog(R.string.choose_an_option,availableChoices.toArray(new Integer[availableChoices.size()]),ExploitFinder.this, new ChoiceDialog.ChoiceDialogListener() {
            @Override
            public void onChoice(int choice) {
              Intent intent;
              switch (availableChoices.get(choice)) {
                case R.string.exploit_launch:
                  //TODO
                  break;
                case R.string.exploit_edit_options:
                  intent = new Intent(ExploitFinder.this, MsfPreferences.class);
                  System.setCurrentExploit(msfEx);
                  ExploitFinder.this.startActivity(intent);
                  break;
                case R.string.payload_edit_settings:
                  intent = new Intent(ExploitFinder.this, MsfPreferences.class);
                  System.setCurrentPayload(msfEx.getCurrentPayload());
                  ExploitFinder.this.startActivity(intent);
                  break;
                case R.string.exploit_choose_payload:
                  //TODO
                  break;
                case R.string.exploit_choose_target:
                  //TODO
                  break;
                case R.string.show_full_description:
                  new ErrorDialog(msfEx.getName(),msfEx.getFullDescription(),ExploitFinder.this).show();
                  break;
              }
            }
          }).show();
        } else {
          if(exp.getUrl() != null && !exp.getUrl().isEmpty())
            startActivity(new Intent( Intent.ACTION_VIEW, Uri.parse(exp.getUrl())));
        }
      }}
    );

    mSearchToggleButton.setOnClickListener( new OnClickListener(){
      @Override
      public void onClick(View ex) {
        if( mRunning )
        {
          setStoppedState();
        }
        else
        {
          setStartedState();
        }
      }}
    );
  }

  @Override
  public boolean onOptionsItemSelected(MenuItem item){
    switch (item.getItemId()) {
      case R.id.exploit_launch_all:
        return true;
      default:
        return super.onOptionsItemSelected(item);
    }
  }

  @Override
  public void onBackPressed() {
    setStoppedState();
    super.onBackPressed();
    overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
  }
}